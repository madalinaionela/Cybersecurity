"""
Copyright (c) 2021, FireEye, Inc.
Copyright (c) 2021 Giorgio Severi

This script shows a defensive approach against the poisoning attack based
on clustering and filtering.

In order to run any mitigation experiment, first run the desired attack for 1 iteration setting the save
parameter of the configuration file to a valid path in the system, and "defense": true.
The attack script will save there a set of artifacts such as the watermarked training and test sets,
and the backdoor trigger details.
"""

import os
import time
import copy
import random
import argparse
from collections import Counter, defaultdict

import numpy as np
import lightgbm as lgb

from sklearn.metrics import confusion_matrix, classification_report

import backdoor_attack
from mw_backdoor import data_utils
from mw_backdoor import embernn
from mw_backdoor import constants
from mw_backdoor import attack_utils
from mw_backdoor import common_utils
from mw_backdoor import defense_utils
from mw_backdoor import notebook_utils
from mw_backdoor import feature_selectors


def run_single_attack(cfg, def_dir):
    """ Run a single instance of the attack saving the poisoned model and data.

    :param cfg: (dict) attack configuration dictionary
    :param def_dir: (str) defense results directory
    :return: None
    """

    print(
        'Will run a single attack to generate the model and training data.\n'
        'The settings for the attacks are:\n'
        '\tAttacked model: {}\n'
        '\tPoison size: {}\n'
        '\tWatermark size: {}\n'
        '\tFeature strategy: {}\n'
        '\tValue strategy: {}\n'
        '\tTarget features: {}'.format(
            cfg['model'],
            cfg['poison_size'],
            cfg['watermark_size'],
            cfg['feature_selection'],
            cfg['value_selection'],
            cfg['target_features']
        )
    )

    cfg['save'] = def_dir
    cfg['iterations'] = 1
    cfg['defense'] = True

    backdoor_attack.run_attacks(cfg)


def check_data(def_dir, current_exp_name):
    """ Check if attacked model and training data are available

    :param def_dir: (str) defense results directory
    :param current_exp_name: (str) identifier of the current experiment
    :return: (bool) true if data is found
    """

    if not os.path.exists(def_dir):
        os.makedirs(def_dir)
        return False

    current_exp_dir = os.path.join(def_dir, current_exp_name)
    if not os.path.exists(current_exp_dir):
        os.makedirs(current_exp_dir)
        return False

    x = os.path.join(current_exp_dir, 'watermarked_X.npy')
    y = os.path.join(current_exp_dir, 'watermarked_y.npy')
    t = os.path.join(current_exp_dir, 'watermarked_X_test.npy')

    if not os.path.exists(x) or not os.path.exists(y) or not os.path.exists(t):
        return False

    print('Found attack data for experiment: {}'.format(current_exp_name))
    return True


def defensive_clustering(method, x_gw, mcs, ms, current_exp_dir):
    """ Perform a clustering over the feature reduced data matrix.

    :param method: (str) clustering method (eg. hdbscan, optics)
    :param x_gw: (ndarray) feature reduced goodware data
    :param mcs: (int) minimum cluster size
    :param ms: (int) minimum samples
    :param current_exp_dir: (str) dir where to save the clustering output
    :return: (clustering, list) clustering object, label list
    """

    if method == 'hdbscan':
        clustering, clustering_labels = defense_utils.cluster_hdbscan(
            data_mat=x_gw,
            metric='euclidean',
            min_clus_size=mcs,
            min_samples=ms,
            n_jobs=32,
            save_dir=current_exp_dir
        )

    else:  # OPTICS
        clustering, clustering_labels = defense_utils.cluster_optics(
            data_mat=x_gw,
            metric='euclidean',
            min_samples=mcs,
            n_jobs=32,
            save_dir=current_exp_dir
        )

    return clustering, clustering_labels


def cluster_analysis(x_gw, clustering_labels, is_clean, current_exp_dir):
    """ Analyze clustering results.

    Produce silhouette scores and count the number of correctly identified
    poisons for each cluster.

    :param x_gw: (ndarray) feature reduced goodware data
    :param clustering_labels: (list) labels generated by clustering
    :param is_clean: (array) bitmap where 0 means poisoned
    :param current_exp_dir: (str) dir where to save results
    :return: (array, dict, Counter, dict)
    """

    silh, avg_silh = defense_utils.compute_silhouettes(
        data_mat=x_gw,
        labels=clustering_labels,
        save_dir=current_exp_dir
    )

    cluster_sizes, evals = defense_utils.show_clustering(
        labels=clustering_labels,
        is_clean=is_clean,
        print_mc=len(set(clustering_labels)),
        print_ev=len(set(clustering_labels)),
        avg_silh=avg_silh
    )

    return silh, avg_silh, cluster_sizes, evals


def filter_clusters(x_train_w, y_train_w, avg_silh, cluster_sizes,
                    clustering_labs, threshold_max_size, min_keep_percentage):
    """ Sample the data using clustering information producing new training set.
    
    Filter goodware points based on silhouette scores. Only filter points from
    clusters with size < threshold_max_size; and keep at least
    min_keep_percentage % points for each cluster.

    :param x_train_w: (array) original backdoored training set
    :param y_train_w: (array) original backdoored training labels
    :param avg_silh: (dict) average silhouette score per cluster
    :param cluster_sizes: (dict) size of each cluster
    :param clustering_labs: (list) clustering labels
    :param threshold_max_size: (int) max size of clusters to sub-sample from
    :param min_keep_percentage: (float) fixed percentage of points to keep
    :return: (array, array) new backdoored training set with labels
    """

    # Split gw, mw
    x_gw = x_train_w[y_train_w == 0]
    x_mw = x_train_w[y_train_w == 1]
    y_gw = y_train_w[y_train_w == 0]
    y_mw = y_train_w[y_train_w == 1]
    print(
        'Shape of the old training data\n'
        '\tx_gw: {}\tx_mw: {}\n\ty_gw: {}\ty_mw: {}'.format(
            x_gw.shape, x_mw.shape, y_gw.shape, y_mw.shape
        )
    )

    # Assign to each point the silhouette score of its cluster
    expand_silh = np.array(
        [avg_silh[j] if cluster_sizes[j] <= threshold_max_size else -1
         for j in clustering_labs]
    )

    # Bring silhouette values in [0,1] range
    std_silh = defense_utils.standardize_data(
        data_mat=expand_silh.reshape(-1, 1),
        feature_range=(0, 1)
    )

    # Sampling rate = 1 - silhouette
    scores = np.ones(std_silh.shape)
    scores = (scores - std_silh) + min_keep_percentage

    # Random probability for each point
    rand_draw = np.random.random_sample(scores.shape)

    # Select points with score > prob
    selected = (scores >= rand_draw).flatten()
    print('Shape of the selected data: {}'.format(selected.shape))
    print('Number of selected samples: {}'.format(sum(selected)))

    # Compute number of points selected for each cluster
    selected_per_cluster = Counter()
    for i in range(len(clustering_labs)):
        if selected[i]:
            selected_per_cluster[clustering_labs[i]] += 1
    print('Number of selected samples per cluster\n', selected_per_cluster)

    # Compute final sampled data matrix
    x_gw_sampled = x_gw[selected]
    y_gw_sampled = y_gw[selected]
    print('Shape of the sampled goodware\n\tX: {}\n\ty: {}'.format(
        x_gw_sampled.shape, y_gw_sampled.shape
    ))

    # Generate new data for training
    x_train_w_sampled = np.concatenate((x_mw, x_gw_sampled), axis=0)
    y_train_w_sampled = np.concatenate((y_mw, y_gw_sampled), axis=0)
    print('Shape of the new training data\n\tX: {}\n\ty: {}'.format(
        x_train_w_sampled.shape, y_train_w_sampled.shape
    ))

    return x_train_w_sampled, y_train_w_sampled, selected, selected_per_cluster


def evaluate_filtering(mod, x_train_w_sampled, y_train_w_sampled, x_test_mw,
                       current_exp_dir, modifier=''):
    """ Evaluate the result of the filtering defense.
    
    Test the sub-sampled data by training a new model on it. Evaluate the new 
    model against clean and backdoored data.

    :param mod: (str) attacked model identifier
    :param x_train_w_sampled: (array) new sub-sampled backdoored training set
    :param y_train_w_sampled: (array) new backdoored training labels
    :param x_test_mw: (array) backdoored testing malware
    :param current_exp_dir: (str) dir where to save results
    :param modifier: (str) modifier for experimental spectral filter
    :return: report and confusion matrix on both clean and backdoored data
    """

    x_train, y_train, x_test, y_test = data_utils.load_ember_dataset()

    # Train new backdoored model
    if mod == 'lightgbm':
        start_time = time.time()
        backdoor_model = notebook_utils.train_model(
            x_train_w_sampled,
            y_train_w_sampled
        )
        print('Training the new model took {:.2f} seconds'.format(
            time.time() - start_time))
        backdoor_model.save_model(
            os.path.join(current_exp_dir, modifier + '_' + 'filter_backdoor')
        )

    else:
        start_time = time.time()
        backdoor_model = notebook_utils.train_nn_model(
            x_train_w_sampled,
            y_train_w_sampled
        )
        print('Training the new model took {:.2f} seconds'.format(
            time.time() - start_time))

        backdoor_model.save(current_exp_dir, modifier + '_' + 'filter_backdoor_nn.h5')

    # Test on clean data
    clean_pred = backdoor_model.predict(x_test)
    clean_pred = np.array([1 if pred > 0.5 else 0 for pred in clean_pred])

    cr_clean = classification_report(
        y_test,
        clean_pred,
        digits=5,
        output_dict=True
    )
    cm_clean = confusion_matrix(y_test, clean_pred)
    print('Performance on clean data:')
    print(classification_report(
        y_test,
        clean_pred,
        digits=5
    ))
    print(confusion_matrix(y_test, clean_pred))

    # Test on backdoored malware
    backdoor_pred = backdoor_model.predict(x_test_mw)
    backdoor_pred = np.array([1 if pred > 0.5 else 0 for pred in backdoor_pred])
    backdoor_y = np.ones_like(backdoor_pred)

    cr_backdoor = classification_report(
        backdoor_y,
        backdoor_pred,
        digits=5,
        output_dict=True
    )
    cm_backdoor = confusion_matrix(backdoor_y, backdoor_pred)
    print('Performance on backdoored malware:')
    print(classification_report(
        backdoor_y,
        backdoor_pred,
        digits=5
    ))
    print(confusion_matrix(backdoor_y, backdoor_pred))

    return cr_clean, cm_clean, cr_backdoor, cm_backdoor


def get_original_shap(mod, feature_names):
    if mod == 'lightgbm':
        x_train, y_train, x_test, y_test, original_model = \
            attack_utils.get_ember_train_test_model()

        shap_values_df, _ = attack_utils.get_shap_importances_dfs(
            original_model,
            x_train,
            feature_names
        )

    else:
        x_train, y_train, x_test, y_test, original_model = \
            attack_utils.get_nn_train_test_model()

        shap_values_df = attack_utils.get_nn_shap_dfs(
            original_model,
            x_train
        )
    del x_train, y_train, x_test, y_test, original_model

    return shap_values_df


def load_bdr_model(mod, exp_dir, x_train):
    """ Load backdoored model.

    :param mod: (str) identifier of the model
    :param exp_dir: (str) path of the model
    :param x_train: (ndarray) data for initialization (EmberNN)
    :return: backdoored model object
    """

    if mod == 'lightgbm':
        backdoor_model = lgb.Booster(
            model_file=os.path.join(
                exp_dir,
                'backdoor_model'
            )
        )

    else:  # EmberNN
        backdoor_model = embernn.EmberNN(x_train.shape[1])
        backdoor_model.load(
            os.path.join(exp_dir, 'backdoor_model.h5'),
            x_train
        )

    return backdoor_model


def print_bdr_baseline(x_test_mw, backdoor_model):
    """ Print accuracy of the backdoored model on watermarked malware.

    :param x_test_mw: (ndarray) watermarked test data
    :param backdoor_model: (model) backdoored model
    :return:
    """

    print('Baseline accuracy on backdoors of the attacked model')
    y_mw_test = np.ones(shape=x_test_mw.shape[0])
    bdr_pred = backdoor_model.predict(x_test_mw)
    bdr_pred = np.array(
        [1 if pred > 0.5 else 0 for pred in bdr_pred]
    )

    cr = classification_report(y_mw_test, bdr_pred, digits=5, output_dict=True)
    print(classification_report(y_mw_test, bdr_pred, digits=5))

    cm = confusion_matrix(y_mw_test, bdr_pred)
    print(confusion_matrix(y_mw_test, bdr_pred))

    return cr, cm


def filtering_defense(cfg):
    # Setup
    seed = cfg['seed']
    np.random.seed(seed)
    random.seed(seed)
    mod = cfg['model']
    method = cfg['clustering']
    target = cfg['target_features']
    safe_mode = cfg['safe']

    base_def_dir = 'results/defense'
    if not os.path.exists(base_def_dir):
        os.makedirs(base_def_dir)

    watermark_sizes = cfg['watermark_size']
    poison_sizes = cfg['poison_size']
    feature_selection = cfg['feature_selection']
    value_selection = cfg['value_selection']

    results = defaultdict(dict)

    features, feature_names, name_feat, feat_name = \
        data_utils.load_features(
            constants.infeasible_features
        )

    feat_value_selector_pairs = common_utils.get_feat_value_pairs(
        feat_sel=list(feature_selection),
        val_sel=list(value_selection)
    )

    # Defense parameters
    t_max_size = cfg['t_max'] * constants.EMBER_TRAIN_SIZE
    min_keep_percentage = cfg['min_keep']
    mcs = int(cfg['mcs'] * constants.EMBER_TRAIN_SIZE)
    ms = int(cfg['ms'] * constants.EMBER_TRAIN_SIZE)
    print(
        'Minimum cluster size: {}\n'
        'Minimum samples: {}'.format(
            mcs, ms
        )
    )

    for w_s in watermark_sizes:
        for p_s in poison_sizes:
            is_clean = defense_utils.get_is_clean(p_s)
            bdr_indices = set(np.argwhere(is_clean == 0).flatten().tolist())

            for (f_s, v_s) in feat_value_selector_pairs:
                # Generate current exp/dir names
                def_dir = os.path.join(base_def_dir, str(w_s), str(p_s))
                current_exp_name = common_utils.get_exp_name(
                    mod, f_s, v_s, target
                )
                current_exp_dir = os.path.join(def_dir, current_exp_name)

                # Check if attack data is available
                if not check_data(def_dir, current_exp_name):
                    cfg_copy = copy.deepcopy(cfg)
                    cfg_copy['watermark_size'] = [w_s, ]
                    cfg_copy['poison_size'] = [p_s, ]
                    cfg_copy['feature_selection'] = [f_s, ]
                    cfg_copy['value_selection'] = [v_s, ]
                    run_single_attack(cfg_copy, def_dir)

                # Prepare feature importance/SHAPs DataFrame
                if safe_mode:  # Assume small percentage of safe data
                    x_safe, y_safe, safe_model = defense_utils.get_safe_dataset_model(
                        mod, safe_pct=0.2, rand=seed
                    )
                    shap_values_df = defense_utils.get_defensive_shap_dfs(
                        mod,
                        safe_model,
                        x_safe
                    )

                else:  # Assume defender has access to full clean model/data
                    shap_values_df = get_original_shap(mod, feature_names)

                # Load attack data
                x_train_w, y_train_w, x_test_mw = \
                    defense_utils.load_attack_data(
                        current_exp_dir
                    )
                backdoor_model = load_bdr_model(
                    mod=mod,
                    exp_dir=current_exp_dir,
                    x_train=x_train_w
                )

                # Baselines on the attacked model
                print_bdr_baseline(x_test_mw, backdoor_model)

                # Get n most important features
                def_feat_sel = feature_selectors.ShapleyFeatureSelector(
                    shap_values_df,
                    criteria=constants.feature_selection_criterion_large_shap,
                    fixed_features=features['non_hashed']
                )

                def_feats = def_feat_sel.get_features(config['topfeats'])
                print('Top {} selected defensive features:\n{}'.format(
                    cfg['topfeats'], def_feats
                ))

                # Dimensionality reduction through feature selection
                x_sel, x_gw_sel, x_mw_sel = defense_utils.reduce_to_feats(
                    x_train_w,
                    def_feats,
                    y_train_w
                )
                assert x_sel.shape[0] == x_train_w.shape[0]
                assert x_sel.shape[1] == cfg['topfeats']

                x_gw_sel_std = defense_utils.standardize_data(x_gw_sel)

                print('-' * 80)
                print('Current experiment: {}'.format(current_exp_name))
                print('-' * 80)

                # Clustering
                clustering, clustering_labels = defensive_clustering(
                    method=method,
                    x_gw=x_gw_sel_std,
                    mcs=mcs,
                    ms=ms,
                    current_exp_dir=current_exp_dir
                )

                # Cluster analysis
                silh, avg_silh, cluster_sizes, evals = cluster_analysis(
                    x_gw=x_gw_sel_std,
                    clustering_labels=clustering_labels,
                    is_clean=is_clean,
                    current_exp_dir=current_exp_dir
                )

                # Filter
                x_train_w_sampled, y_train_w_sampled, selected, selected_per_cluster = filter_clusters(
                    x_train_w=x_train_w,
                    y_train_w=y_train_w,
                    avg_silh=avg_silh,
                    cluster_sizes=cluster_sizes,
                    clustering_labs=clustering_labels,
                    threshold_max_size=t_max_size,
                    min_keep_percentage=min_keep_percentage
                )
                results[(w_s, p_s, f_s, v_s)]['selected'] = selected
                results[(w_s, p_s, f_s, v_s)]['selected_per_cluster'] = selected_per_cluster

                # Evaluation
                cr_clean, cm_clean, cr_backdoor, cm_backdoor = evaluate_filtering(
                    mod=mod,
                    x_train_w_sampled=x_train_w_sampled,
                    y_train_w_sampled=y_train_w_sampled,
                    x_test_mw=x_test_mw,
                    current_exp_dir=current_exp_dir,
                )
                results[(w_s, p_s, f_s, v_s)]['cr_clean'] = cr_clean
                results[(w_s, p_s, f_s, v_s)]['cm_clean'] = cm_clean
                results[(w_s, p_s, f_s, v_s)]['cr_backdoor'] = cr_backdoor
                results[(w_s, p_s, f_s, v_s)]['cm_backdoor'] = cm_backdoor

                # Spectral signatures-like approach
                to_remove_gh, to_remove_pa, found_gh, found_pa = defense_utils.spectral_remove_lists(
                    x_gw_sel_std, bdr_indices
                )
                results[(w_s, p_s, f_s, v_s)]['to_remove_gh'] = to_remove_gh
                results[(w_s, p_s, f_s, v_s)]['to_remove_pa'] = to_remove_pa
                results[(w_s, p_s, f_s, v_s)]['found_gh'] = found_gh
                results[(w_s, p_s, f_s, v_s)]['found_pa'] = found_pa

                x_train_w_filtered_gh, y_train_w_filtered_gh = defense_utils.filter_list(
                    x_train_w,
                    y_train_w,
                    to_remove_gh
                )

                cr_clean_gh, cm_clean_gh, cr_backdoor_gh, cm_backdoor_gh = evaluate_filtering(
                    mod=mod,
                    x_train_w_sampled=x_train_w_filtered_gh,
                    y_train_w_sampled=y_train_w_filtered_gh,
                    x_test_mw=x_test_mw,
                    current_exp_dir=current_exp_dir,
                    modifier='gh'
                )
                results[(w_s, p_s, f_s, v_s)]['cr_clean_gh'] = cr_clean_gh
                results[(w_s, p_s, f_s, v_s)]['cm_clean_gh'] = cm_clean_gh
                results[(w_s, p_s, f_s, v_s)]['cr_backdoor_gh'] = cr_backdoor_gh
                results[(w_s, p_s, f_s, v_s)]['cm_backdoor_gh'] = cm_backdoor_gh

                x_train_w_filtered_pa, y_train_w_filtered_pa = defense_utils.filter_list(
                    x_train_w,
                    y_train_w,
                    to_remove_pa
                )

                cr_clean_pa, cm_clean_pa, cr_backdoor_pa, cm_backdoor_pa = evaluate_filtering(
                    mod=mod,
                    x_train_w_sampled=x_train_w_filtered_pa,
                    y_train_w_sampled=y_train_w_filtered_pa,
                    x_test_mw=x_test_mw,
                    current_exp_dir=current_exp_dir,
                    modifier='pa'
                )
                results[(w_s, p_s, f_s, v_s)]['cr_clean_pa'] = cr_clean_pa
                results[(w_s, p_s, f_s, v_s)]['cm_clean_pa'] = cm_clean_pa
                results[(w_s, p_s, f_s, v_s)]['cr_backdoor_pa'] = cr_backdoor_pa
                results[(w_s, p_s, f_s, v_s)]['cm_backdoor_pa'] = cm_backdoor_pa

    np.save(os.path.join(base_def_dir, mod + '__def_dict'), results)

    return results


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-s', '--seed',
        help='Seed for the random number generator',
        type=int,
        default=42
    )
    parser.add_argument(
        '-c', '--config',
        help='Defense configuration file path',
        type=str,
        required=True
    )
    parser.add_argument(
        '-t', '--topfeats',
        help='Number of top features to consider',
        type=int,
        default=32
    )
    arguments = parser.parse_args()

    # Unwrap arguments
    args = vars(arguments)
    config = common_utils.read_config(args['config'], atk_def=False)
    config['seed'] = args['seed']
    config['topfeats'] = args['topfeats']

    filtering_defense(config)
